> 바킹독님의 실전 알고리즘 강좌를 정리한 내용입니다.


# BFS (너비 우선 탐색)

##  BFS의 정의와 성질
*   **정의:** 다차원 배열(그래프)에서 각 칸을 방문할 때, **너비를 우선으로** 방문하는 알고리즘.
*   **비유:** 잔잔한 호수에 돌을 던졌을 때 물결이 퍼져나가는 모양과 같다. (시작점을 중심으로 거리 1인 곳, 그 다음 거리 2인 곳... 순서로 퍼져나감)
*   **용도:**
    1.  그래프 상에서 모든 점을 방문하고 싶을 때 (Flood Fill).
    2.  **최단 거리**를 구해야 할 때 (가중치가 1인 그래프에서).
*   **시간 복잡도:** $O(V + E)$ 혹은 행렬 기준 $O(R \times C)$. (칸의 개수만큼 시간 소요)

## 알고리즘 흐름 
1.  **시작하는 칸**을 큐에 넣고 방문했다는 표시를 남긴다.
2.  큐가 비어있지 않은 동안 다음을 반복한다:
    *   큐의 **가장 앞(front)** 원소를 꺼낸다 (`cur`).
    *   `cur`의 **상하좌우** 인접한 칸들을 확인한다.
    *   인접한 칸이 **범위를 벗어나지 않았고** & **아직 방문하지 않았다면**:
        *   큐에 넣는다 (`push`).
        *   방문했다는 표시를 남긴다.

## 구현 템플릿 (암기 필수)
자주 쓰이는 2차원 배열 BFS 기본 코드.
```cpp
#include <bits/stdc++.h>
using namespace std;
#define X first
#define Y second

int board[502][502]; // 맵 정보
bool vis[502][502]; // 방문 여부
int n, m; // 행, 열
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main(void){
    ios::sync_with_stdio(0); cin.tie(0);
    // ... 입력 처리 ...
    
    queue<pair<int,int>> Q;
    vis[0][0] = 1; // 시작점 방문 표시
    Q.push({0,0}); // 시작점 큐에 삽입
    
    while(!Q.empty()){
        pair<int,int> cur = Q.front(); Q.pop();
        for(int dir = 0; dir < 4; dir++){
            int nx = cur.X + dx[dir];
            int ny = cur.Y + dy[dir];
            
            // 1. 범위 체크 (가장 중요)
            if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            // 2. 방문 여부 및 갈 수 있는 칸인지 체크
            if(vis[nx][ny] || board[nx][ny] != 1) continue;
            
            vis[nx][ny] = 1; // ★ 큐에 넣을 때 방문 표시
            Q.push({nx, ny});
        }
    }
}
```

## BFS 응용 및 유형
### 거리 측정 (Shortest Path)
*   단순 방문 여부(`vis`)만 체크하는 것이 아니라, **시작점으로부터의 거리**를 저장한다.
*   `dist` 배열을 -1로 초기화하고, 방문 시 `dist[nx][ny] = dist[cur.X][cur.Y] + 1` 로 갱신.

### 시작점이 여러 개일 때 (Multi-Source BFS)
*   예: [BOJ 7576 토마토]. 익은 토마토가 여러 곳에 있는 경우.
*   **해결법:** 모든 시작점(익은 토마토)을 **큐에 미리 다 넣어두고** BFS를 시작하면 된다.

### 시작점이 두 종류일 때 (불과 지훈이)
*   예: [BOJ 4179 불!]. 불도 번지고 지훈이도 이동해야 함.
*   **해결법:** 불에 대한 BFS를 먼저 돌려서 각 칸에 불이 도착하는 시간을 구하고, 그 다음 지훈이에 대한 BFS를 돌려서 불보다 빨리 도착할 수 있는지 비교한다.

##  자주 하는 실수 (주의사항)
1.  **방문 표시 시점:**
    *   큐에서 **뺄 때(pop)** 방문 표시를 하면 안 된다. 중복 방문이 발생하여 시간 복잡도가 폭발함.
    *   반드시 큐에 **넣을 때(push)** 방문 표시를 해야 한다.
2.  **범위 체크:**
    *   `nx`, `ny`가 배열 범위를 벗어나는지 확인하는 코드가 `vis` 배열 접근보다 **먼저** 와야 한다. (안 그러면 인덱스 에러 발생)
3.  **행(row)과 열(column) 혼동:**
    *   보통 `board[row][col]` 순서인데, `x`를 행으로, `y`를 열로 두는 경우(`board[x][y]`)와 좌표계(`(x, y)`)가 헷갈릴 수 있다.
    *   일관되게 `board[x][y]` (x가 행, y가 열)로 생각하는 것이 편하다.
