> 바킹독님의 실전 알고리즘 강좌를 듣고 정리한 내용입니다.

# 스택의 활용 (수식의 괄호 쌍)

## 문제 유형의 개요
*   **주제:** 올바른 괄호 문자열(VPS, Valid Parenthesis String) 판단하기.
*   **특징:**
    *   문자열을 순차적으로 읽으면서, 닫는 괄호가 나왔을 때 **가장 최근에 열린 괄호**와 짝이 맞는지 확인해야 한다.
    *   "가장 최근에 들어온 것"을 확인해야 하므로 **스택(FILO)** 자료구조가 필수적이다.

## 올바른 괄호 쌍 판단 알고리즘
문자열을 앞에서부터 한 글자씩 읽으면서 다음 과정을 수행한다.

1.  **여는 괄호 `(`, `{`, `[` 가 나오면:**
    *   스택에 `push` 한다.
2.  **닫는 괄호 `)`, `}`, `]` 가 나오면:**
    *   **Case 1 (스택이 비어있음):** 짝이 맞는 여는 괄호가 없다는 뜻이므로 **올바르지 않은 괄호**.
    *   **Case 2 (스택의 `top`과 짝이 안 맞음):** `(]` 처럼 종류가 다른 경우이므로 **올바르지 않은 괄호**.
    *   **Case 3 (스택의 `top`과 짝이 맞음):** 짝을 찾았으므로 스택에서 `pop` 한다.
3.  **모든 문자를 다 읽었을 때:**
    *   **스택이 비어있지 않다면:** 여는 괄호가 남았다는 뜻이므로 **올바르지 않은 괄호**.
    *   **스택이 비어있다면:** **올바른 괄호**.

## 심화 문제: 괄호의 값 (BOJ 2504)
단순히 올바른지 판단하는 것을 넘어, 괄호 구조에 따라 값을 계산해야 하는 까다로운 문제.
*   `()` = 2, `[]` = 3
*   `(X)` = 2 * Value(X), `[X]` = 3 * Value(X)
*   `XY` = Value(X) + Value(Y)

### **핵심 해결 전략 (분배 법칙 활용)**
스택 안에서 복잡하게 계산하려 하지 말고, **변수 `num`을 이용해 곱해나가다가 더하는 방식**을 쓴다.
예: `(()[[]])` 계산 시
1.  **`num` 변수:** 초기값 1. 여는 괄호를 만날 때마다 해당 괄호의 값(2 또는 3)을 곱한다.
2.  **여는 괄호 `(`:** `num *= 2`, 스택에 `(` 푸시.
3.  **닫는 괄호 `)`:**
    *   올바른 괄호인지 체크(비었거나 짝 안 맞으면 에러).
    *   **핵심:** **바로 직전 문자가 `(` 였으면**, 괄호가 닫히는 순간이므로 `ans += num` (현재까지 곱해진 값을 결과에 더함).
    *   직전 문자가 `)` 였으면, 이미 안쪽에서 계산해서 더했으므로 그냥 넘어감.
    *   괄호가 끝났으므로 `num /= 2`, 스택 팝.

```cpp
// 괄호의 값 계산 로직 (일부)
if(str[i] == '('){
    num *= 2; 
    S.push(str[i]);
}
else if(str[i] == ')'){
    if(S.empty() || S.top() != '('){ /* invalid */ break; }
    if(str[i-1] == '(') ans += num; // 바로 직전이 여는 괄호일 때만 더함
    S.pop();
    num /= 2; // 괄호 밖으로 나감
}
```

## 주의사항 및 팁
*   **스택 Empty 체크:** 닫는 괄호가 나왔을 때 스택이 비어있는지 반드시 먼저 확인해야 한다. (런타임 에러 방지)
*   **입력 종료 후 체크:** 반복문이 끝난 뒤에도 스택에 잔여물이 남아있다면 틀린 괄호 문자열이다.
*   **getline:** 공백이 포함된 문자열을 입력받을 때(BOJ 4949 균형잡힌 세상)는 `cin` 대신 `getline(cin, s)`를 사용해야 한다.

