> 바킹독님의 실전 알고리즘 강좌를 듣고 정리한 내용입니다.

# 연결 리스트

## 연결 리스트의 정의와 성질
- 정의: 원소들을 저장할 때, 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조.
- 성질
  - k번째 원소접근: $O(k)$가 걸린다. 배열과 달리 바로 접근이 불가능하고, 앞에서부터 순차적으로 접근해야하기때문.
  - 임의의 위치에 원소 추가/제거: $O(1)$가 걸린다. 단, 해당위치의 주소를 알고 있다고 가정한다.
  - 메모리: 원소들이 메모리상에 연속적이지 않아도된다.
- 종류: 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트

## 배열 vs 연결 리스트 비교

| 기능 | 배열 (Array) | 연결 리스트 (Linked List) |
| --- | --- | --- |
| k번째 원소 접근 | $O(1)$ | $O(k)$  |
| 임의의 위치에 추가/제거 | $O(N)$  | $O(1)$  |
| 메모리 할당 | 고정 크기 (Overhead 거의 없음) | 동적 할당 (Overhead 존재) |

**핵심:** 데이터의 **중간에 삽입/삭제가 빈번**하다면 연결 리스트를, **특정 인덱스 조회**가 빈번하다면 배열을 사용하는 것이 유리하다.

## 기능구현과 STL

### STL std::list
- C++에서는 구조체를 직접 만들 필요 없이 `std::list`를 사용하면 된다.
- 주요 메소드: `push_back`, `push_front`, `pop_back`, `pop_front`, `insert`, `erase`
- 주의할점 (Iterator)
  - `erase(it)`를 수행하면 `it`가 가리키는 원소가 삭제되어 해당 반복자는 무효화 된다.
  - 따라서 `it = L.erase(it)`형태로 삭제후 반환되는 다음원소의 반복자를 받아야함.

### 코테용 야매 연결리스트
STL을 못 쓰거나 메모리 제한이 빡빡한경우, 배열을 이용해 정적으로 구현하는 방식(사실상 쓸 일 x)
```cpp
const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

// 0번지는 더미 노드(Dummy Node)로 사용 (Head 역할)
fill(pre, pre+MX, -1);
fill(nxt, nxt+MX, -1);
```