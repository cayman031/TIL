> 바킹독님의 실전 알고리즘 강좌를 듣고 정리한 내용입니다.

# 덱

## 덱의 정의와 성질

* 덱은 **Restricted Structure의 끝판왕** 같은 느낌.
* **양쪽 끝에서 삽입과 삭제가 전부 가능**한 자료구조.
* 양쪽에서 넣고/빼기가 되니까, **스택과 큐를 덱의 특수한 예시**로 생각해도 됨.

## 시간복잡도 / 가능한 연산

* 덱에서도
  * **삽입**, **삭제**, **제일 앞/뒤 원소 확인**이 전부 $O(1)$.
* 원칙적으로는 **제일 앞/뒤가 아닌 나머지 원소 확인/변경은 불가능**.

  * 그런데 **STL `deque`는 인덱스로 접근이 가능**해서 좀 독특함.
  * STL `stack`, `queue`에서는 안 됐던 걸 생각하면 꽤 특이한 포인트이다.

## 구현은 배열로(스택/큐랑 비슷하게)
* 덱도 스택/큐처럼 **배열 / 연결 리스트** 둘 다로 구현 가능.
* 그런데 **배열로 구현하는 게 더 쉬워서** 여기서는 배열 구현만.

필요한 건 큐랑 거의 동일:

* 원소를 담을 **큰 배열 1개**
* 앞/뒤를 가리킬 **변수 2개**

그리고 **head/tail 정의도 큐랑 동일**하게 둠:

* `head` = **가장 앞 원소의 인덱스**
* `tail` = **가장 뒤 원소의 인덱스 + 1**

여기서 중요한 차이:

* `head`, `tail` 초기값이 0이 아니라 **MX**.



## head/tail을 왜 MX에서 시작하냐

큐는 보통 이런 모양이었음:

* 앞쪽에서는 **제거만**, 뒤쪽에서는 **삽입만**
* 그래서 배열에서 실제 큐가 차지하는 구간이 **오른쪽으로 이동하면서 확장**.

근데 덱은 다름:

* 덱은 **양쪽에서 삽입이 가능**함.
* 그러면 **여의봉처럼 양쪽으로 확장**해야 하는데,

  * 시작을 0번지로 두면 **왼쪽으로 확장을 못 함**.

그래서

* 시작 지점을 **배열의 중간**으로 둠.
* 중간에서 시작하면 중앙에서 **양쪽으로 확장** 가능.
* 그래서 보통

  * 배열 크기 = `2*MX + 1`
  * `head = tail = MX`



## 원형 덱? 선형 덱?

* 덱도 원형으로 구현할 수는 있음.
* 하지만 코딩테스트에서는 **배열을 충분히 크게 잡으면 되니까**
  **선형으로만 구현**해도 충분한 편.

우리가 구현해야 할 함수는 딱 이 6개

* `push_front`, `push_back`
* `pop_front`, `pop_back`
* `front`, `back`

## STL `deque`는 뭐가 독특하냐 (deque vs vector)

* STL에 덱이 있으니 그냥 가져다 써도 됨.
* 그런데 STL `deque`은 느낌이 약간

  * “double ended queue”라기보다
  * **`vector`랑 비슷한데 front에서도 O(1)로 추가/제거 가능한** 쪽에 가까움.

왜냐면 STL `deque`는

* `push_front/pop_front`, `push_back/pop_back`은 당연히 있고
* 거기에 더해서

  * `insert`, `erase`도 있고
  * **인덱스로 원소 접근도 가능**함.

그래서 “deque가 vector 상위호환인가?” 생각할 수 있는데,

* `vector`와 달리 `deque`는 **모든 원소가 메모리상 연속(contiguous) 배치가 아님**.
* 구조 얘기는 난이도 벗어나니 궁금하면 `c++ deque vs vector` 같은 키워드로 찾아보기.

딱 하나만 가져가면

* 앞/뒤에서 추가/제거가 모두 필요 → **`deque`**
* 굳이 앞쪽 작업이 필요 없고 배열 같은 느낌으로 쓰고 싶다 → **`vector`**


