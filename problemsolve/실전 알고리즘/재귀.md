> 바킹독님의 실전 알고리즘을 보고 정리한 내용입니다.

# 재귀

## 재귀의 정의와 사고방식
- 정의: 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘.
- 핵심 사고방식(재귀적 사고)
  - 우리는 보통 코드를 작성할 때 A를 하고 그 다음 B를 하고 식의 절차지향적 사고에 익숙하다.
  - 하지만 재귀를 잘 하려면 귀납적 사고로 전환해야 한다.
  - 도미노 예시
    - 절차지향: 1번이 쓰러지면 2번이 쓰러지고, 2번이 쓰러지면 3번이 쓰러진다(과정을 하나하나 따라간다).
    - 귀납적(재귀)
      - 1번 도미노가 쓰러진다(base)
      - k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다(step)
      - 결론: 모든 도미노가 쓰러진다.
    - 적용: `func(n)`을 풀기위해 `func(n-1)`이 올바른 결과를 준다고 믿고 로직을 짠다.

## 올바른 재귀함수의 조건
재귀 함수가 무한 루프에 빠지지않고 정상 종료되려면 다음 두 가지 조건이 필수적이다.
1. Base Condition: 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료해야한다.
2. Convergence: 모든 입력은 결국 Base Condition으로 수렴해야 한다.
```cpp
void func1(int n) {
    if(n == 0) return; // Base Condition
    cout << n << ' ';
    func1(n-1);        // 입력 n이 0으로 수렴함
}
```

## 재귀 사용시 주의사항
- 함수 호출 비용: 재귀는 함수를 계속 호출하므로 반복문보다 메모리와 시간 면에서 손해를 본다.
- 스택 메모리제한: 일부 코테 환경이나 시스템은 스택 메모리를 작게 제한하기도 한다. 이 경우 깊은 재귀는 스택 오버플로우를 일으키므로 반복문으로 대체해야 한다.
- 중복 계산(피보나치 수열)
  - `fibo(n) = fibo(n-1) + fibo(n-2)`와 같이 짜면 이미 구한 값을 또 구하는라 시간 복잡도가 폭발할 수 있다.
  - 이런 경우 DP를 사용하자.

